# Leetcode - 2875. Minimum Size Subarray in Infinite Array (H-)

[Leetcode](https://leetcode.com/problems/minimum-size-subarray-in-infinite-array/)

You are given a **0-indexed** array `nums` and an integer `target`.

A **0-indexed** array `infinite_nums` is generated by infinitely appending the elements of `nums` to itself.

Return _the length of the **shortest** subarray of the array _`infinite_nums`_ with a sum equal to _`target`_._ If there is no such subarray return `-1`.

**Example 1:**

> **Input:** nums = [1,2,3], target = 5
> **Output:** 2
> **Explanation:** In this example infinite_nums = [1,2,3,1,2,3,1,2,...].
> The subarray in the range [1,2], has the sum equal to target = 5 and length = 2.
> It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.

**Example 2:**

> **Input:** nums = [1,1,1,2,3], target = 4
> **Output:** 2
> **Explanation:** In this example infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...].
> The subarray in the range [4,5], has the sum equal to target = 4 and length = 2.
> It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.

**Example 3:**

> **Input:** nums = [2,4,6,8], target = 3
> **Output:** -1
> **Explanation:** In this example infinite_nums = [2,4,6,8,2,4,6,8,...].
> It can be proven that there is no subarray with sum equal to target = 3.

**Constraints:**

-   `1 <= nums.length <= 105`
-   `1 <= nums[i] <= 105`
-   `1 <= target <= 109`

---
```java
// Java 6ms(Beats 94.32%), Time O(N), Space O(1)
class Solution {
    public int minSizeSubarray(int[] nums, int target) {
        int sum = 0;
        int n = nums.length;
        for (int num : nums)
            sum += num;
        int t = target;
        t %= sum;
        int j = 0;
        int ret = n + 1;
        for (int i = 0; i < 2 * n; i++)
        {
            while (j < 2 * n && t > 0)
            {
                t -= nums[j % n];
                j++;
            }

            if (t == 0)
                ret = Math.min(ret, j - i);
            
            t += nums[i % n];
        }
        
        return ret == n + 1 ? -1 : ret + target / sum * n;
    }
}
```
---

很顯然，任何一個`subarray`，都可以表示成`nums的某個後綴 + 若干個重複的nums + nums的某個前綴`

我們將`nums`重複一次(長度變成`2n`)之後，上述的`subarray sum`就是：`nums[i:j] + k * total`
其中`total = nums[0:n-1]之和`
`[i:j]`是在`[0:2n-1]`上的子區間
`k`是某個整數(可以是`0`)

`k = target / sum`
`nums[i:j] = nums重複一遍(長度2n)之後，在上面找subarray = target % sum`



###### tags: `Leetcode` `Two Pointers` `Sliding window`